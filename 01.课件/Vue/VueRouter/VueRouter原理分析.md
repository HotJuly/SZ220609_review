# VueRouter复习

1. 说说你对VueRouter的了解
   1. 他是一个npm包
   2. 他是Vue的扩展插件库(Vue.use)
   3. 这个库可以让我们实现单页面应用
      1. 问题:什么是单页面应用?
         1. 页面就是html文件
         2. 整个项目中,只有一个html文件
         3. 单页面应用其实就是在一个html文件上面,使用DOM的增删改查方法,对页面的结构进行修改,从而实现不同内容的展示
         4. 扩展问题:大家有没有做过多页面应用?
            1. 其实做过,就是尚品汇静态样式
            2. 多页面应用是一种老的技术,所以逐渐被单页面应用替代了
      2. 问题:单页面应用只有框架可以实现吗?
         1. 并不是,哪怕只用原生的DOM方法都能实现
      3. 问题:请问Vue不使用VueRouter能否实现单页面应用?
         1. 可以,可以使用v-if,v-show或者component组件都能实现类似效果

2. VueRouter会提供给我们什么东西?
   1. 构造函数
      1. 通过该构造函数,可以创建一个路由器对象
   2. 全局组件
      1. router-view
         1. 用处:用于显示路径匹配的路由组件
         2. **核心原理:其实就是内部使用到了响应式原理**
         3. **原理:**
            1. **通过$route对象可以获取到当前路由的路径**
            2. **通过得到的路由路径,去routes数组中找到对应的路由组件**
            3. **使用createElement方法,将该路由组件渲染出来即可**
      2. router-link
         1. 用处:用于生成标签,让用户点击,点击之后会跳转到指定的路由地址下
         2. **声明式导航定义:通过标签的形式,引导用户进行跳转,这类操作称为声明式导航**
         3. **原理:**
            1. **默认会生成一个a标签**
            2. **VueRouter会禁用该a标签的默认行为**
            3. **同时给a标签绑定click事件,在事件回调函数中,使用编程式导航的push方法实现路由跳转功能**
   3. 公共对象
      1. $router
         1. 这是路由器对象
         2. 从他身上可以获取到用于操作控制路由的相关方法
            1. push
               1. 他可以控制路由的跳转,跳转到指定的路由地址
               2. **该方法跳转路由,会保留上一个历史记录,所以可以使用返回方法回到上一个路由**
               3. **原理:**
                  1. hash模式下
                     1. **通过调用window.location.assign(路径),可以控制当前浏览器历史记录栈的变化,并跳转到指定的路由地址下(这是一个伪跳转)**
                  2. history模式下
                     1. **通过调用window.history.pushState({},'',路径),可以控制当前浏览器历史记录栈的变化,并跳转到指定的路由地址下(这是一个伪跳转)**
            2. replace
               1. 他可以控制路由的跳转,跳转到指定的路由地址
               2. **该方法跳转路由,会销毁/覆盖上一个历史记录,所以无法使用返回方法回到上一个路由**
               3. **原理:**
                  1. hash模式下
                     1. **通过调用window.location.replace(路径),可以控制当前浏览器历史记录栈的变化,并跳转到指定的路由地址下(这是一个伪跳转)**
                  2. history模式下
                     1. **通过调用window.history.replaceState({},'',路径),可以控制当前浏览器历史记录栈的变化,并跳转到指定的路由地址下(这是一个伪跳转)**
      2. $route
         1. 这是路由对象
         2. 从他身上可以获取到当前路由相关的信息
            1. fullpath->当前所在的路由路径
            2. query
               1. 他是URL传参的一员
                  1. 传递的参数不能过多,有长度限制
               2. 格式:"/home?key=value"
            3. params
               1. 他是URL传参的一员
                  1. 传递的参数不能过多,有长度限制
               2. 格式:"/home/1"
               3. 注意点:在声明注册路由对象的时候,需要在path中写好占位符
                  1. path:"/home/:id"
            4. meta
               1. 他不是URL传参的一员
               2. 需要在声明路由对象的时候,在path同级的位置属性meta属性,并向内部写入数据
               3. 通过this.$route.meta即可获取到对应的数据

3. 我们需要提供给VueRouter什么东西?
   1. 配置对象
      1. mode属性
         1. hash
            1. 开启hash模式的路由
            2. **原理:**
               1. **VueRouter会给window对象,绑定hashchange事件用于监视地址栏的变化**
               2. **如果事件回调函数触发了,就读取location.hash的值,将该值赋值给$router身上的响应式属性**
                  1. **最终会导致使用到这个响应式属性的组件都更新(指的就是router-view)**
            3. 优点:
               1. 在浏览器眼里,hash模式其实就是锚点
                  1. 兼容性好,IE6+
               2. 上线不需要做任何的特殊配置
            4. 缺点:
               1. 丑就是原罪,太丑了,甲方爸爸看着不开心
               2. 该模式与锚点功能冲突,无法正常使用锚点功能
         2. history
            1. 开启history模式的路由
            2. **原理:**
               1. **VueRouter会给window对象,绑定popstate事件用于监视地址栏的变化**
                  1. **注意:popstate事件,只能在前进后退按钮才能触发事件回调函数**
               2. **如果事件回调函数触发了,就读取location.pathname的值,将该值赋值给$router身上的响应式属性**
                  1. **最终会导致使用到这个响应式属性的组件都更新(指的就是router-view)**
            3. 优点:
               1. 颜值就是正义,好看就行
               2. 对锚点功能没有任何影响,可以正常使用
            4. 缺点:
               1. 兼容性较差,因为源码中使用的history对象,是HTML5的新特性
               2. 上线的时候,需要服务器做出特殊的配置,才能实现项目的正常运行
                  1. 问题:
                     1. 用户停留在某个路由地址下,然后刷新当前浏览器,浏览器就会重新请求服务器
                        1. 浏览器会将/home这个前端路由,发送给后端服务器,请求后端服务器的/home接口
                     2. 服务器接收到/home请求,但是服务器自己没有该接口,就会返回404响应
                     3. 浏览器接收到404,只能在页面上显示出来
                     4. 总结:该流程中,出错的是浏览器,浏览器把前端路由误以为是后端路由了
                  2. 解决方法:
                     1. 用户停留在某个路由地址下,然后刷新当前浏览器,浏览器就会重新请求服务器
                        1. 浏览器会将/home这个前端路由,发送给后端服务器,请求后端服务器的/home接口
                     2. **服务器可以将自己没有的接口,统一返回index.html文件**
                     3. 浏览器解析html文件,发现需要请求index.js文件,于是就会继续请求服务器
                     4. 服务器将index.js文件返回给浏览器
                     5. 浏览器会自动执行index.js文件,而该文件中,具有VueRouter的代码
                     6. VueRouter就会自动获取浏览器地址栏中的地址,进行解析,最终找到需要显示的路由组件,进行显示
      2. routes属性
         1. 数据类型:routeObj[ ]
         2. routeObj对象结构
            1. path
               1. 代表当前路由的路由地址
            2. component
               1. 如果当前地址栏中的路径,与path匹配,页面就需要显示该组件

4. 导航守卫(又称为路由守卫)

   1. 导航守卫可以控制本次跳转的情况,例如:成功跳转,或者失败

      1. 导航守卫就是一些新增的生命周期

   2. 导航守卫一共分为3大类,一共有7个

      1. 全局守卫

         1. 全局前置守卫(beforeEach)

            1. 当触发了路由跳转,在发生跳转操作之前触发

            2. ```javascript
               const router = new VueRouter({ ... })

               router.beforeEach((to, from, next) => {
                 // to => 到达地,想要跳转的路由相关信息
                 // from => 始发地,从哪个路由出发
                 // next => 可以控制当前路由的跳转情况
                 // next() => 放行,允许本次跳转
                 // next(false) => 拒绝,本次跳转失败,从哪来回哪去
                 // next("/login") => 强制用户跳转到指定路由
               })
               ```

               ​

            3. 2

         2. 全局解析守卫(beforeResolve)

            1. 当组件解析结束之后,才会执行

         3. 全局后置守卫(afterEach)

            1. 当触发了路由跳转,在发生跳转操作之后触发,即将到达想要跳转的路由

      2. 路由独享守卫

         1. 即将进入该路由的时候会触发

         2. ```javascript
            const router = new VueRouter({
              routes: [
                {
                  path: '/foo',
                  component: Foo,
                  beforeEnter: (to, from, next) => {
                    // ...
                  }
                }
              ]
            })
            ```

            ​

         3. 2

      3. 组件内置守卫

         1. 组件进入守卫

            1. 即将进入该组件之前会触发

         2. 组件更新守卫

            1. 当一个路由跳转之后,当前路由组件被复用的时候会触发

         3. 组件离开守卫

            1. 在即将离开当前组件的时候会触发
            2. 注意:7个守卫中,只有这一个可以监视离开这个操作

         4. ```javascript
            export default {
              data(){
                return{
                  msg:123
                }
              },
              beforeRouteEnter(to, from, next) {
                // 在渲染该组件的对应路由被 confirm 前调用
                // 不！能！获取组件实例 `this`
                // 因为当守卫执行前，组件实例还没被创建
              },
              beforeRouteUpdate(to, from, next) {
                // 在当前路由改变，但是该组件被复用时调用
                // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
                // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
                // 可以访问组件实例 `this`
              },
              beforeRouteLeave(to, from, next) {
                // 导航离开该组件的对应路由时调用
                // 可以访问组件实例 `this`
              }
            }
            ```

            ​