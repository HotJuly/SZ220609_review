# VueRouter复习

1. 说说你对VueRouter的了解
   1. 他是一个npm包
   2. 他是Vue的扩展插件库(Vue.use)
   3. 这个库可以让我们实现单页面应用
      1. 问题:什么是单页面应用?
         1. 页面就是html文件
         2. 整个项目中,只有一个html文件
         3. 单页面应用其实就是在一个html文件上面,使用DOM的增删改查方法,对页面的结构进行修改,从而实现不同内容的展示
         4. 扩展问题:大家有没有做过多页面应用?
            1. 其实做过,就是尚品汇静态样式
            2. 多页面应用是一种老的技术,所以逐渐被单页面应用替代了
      2. 问题:单页面应用只有框架可以实现吗?
         1. 并不是,哪怕只用原生的DOM方法都能实现
      3. 问题:请问Vue不使用VueRouter能否实现单页面应用?
         1. 可以,可以使用v-if,v-show或者component组件都能实现类似效果
2. VueRouter会提供给我们什么东西?
   1. 构造函数
      1. 通过该构造函数,可以创建一个路由器对象
   2. 全局组件
      1. router-view
         1. 用处:用于显示路径匹配的路由组件
         2. **核心原理:其实就是内部使用到了响应式原理**
         3. **原理:**
            1. **通过$route对象可以获取到当前路由的路径**
            2. **通过得到的路由路径,去routes数组中找到对应的路由组件**
            3. **使用createElement方法,将该路由组件渲染出来即可**
      2. router-link
         1. 用处:用于生成标签,让用户点击,点击之后会跳转到指定的路由地址下
         2. **声明式导航定义:通过标签的形式,引导用户进行跳转,这类操作称为声明式导航**
         3. **原理:**
            1. **默认会生成一个a标签**
            2. **VueRouter会禁用该a标签的默认行为**
            3. **同时给a标签绑定click事件,在事件回调函数中,使用编程式导航的push方法实现路由跳转功能**
   3. 公共对象
      1. $router
         1. 这是路由器对象
         2. 从他身上可以获取到用于操作控制路由的相关方法
            1. push
               1. 他可以控制路由的跳转,跳转到指定的路由地址
               2. **该方法跳转路由,会保留上一个历史记录,所以可以使用返回方法回到上一个路由**
               3. **原理:**
                  1. hash模式下
                     1. **通过调用window.location.assign(路径),可以控制当前浏览器历史记录栈的变化,并跳转到指定的路由地址下(这是一个伪跳转)**
                  2. history模式下
                     1. **通过调用window.history.pushState({},'',路径),可以控制当前浏览器历史记录栈的变化,并跳转到指定的路由地址下(这是一个伪跳转)**
            2. replace
               1. 他可以控制路由的跳转,跳转到指定的路由地址
               2. **该方法跳转路由,会销毁/覆盖上一个历史记录,所以无法使用返回方法回到上一个路由**
               3. **原理:**
                  1. hash模式下
                     1. **通过调用window.location.replace(路径),可以控制当前浏览器历史记录栈的变化,并跳转到指定的路由地址下(这是一个伪跳转)**
                  2. history模式下
                     1. **通过调用window.history.replaceState({},'',路径),可以控制当前浏览器历史记录栈的变化,并跳转到指定的路由地址下(这是一个伪跳转)**
      2. $route
         1. 这是路由对象
         2. 从他身上可以获取到当前路由相关的信息
            1. fullpath->当前所在的路由路径
            2. query
               1. 他是URL传参的一员
                  1. 传递的参数不能过多,有长度限制
               2. 格式:"/home?key=value"
            3. params
               1. 他是URL传参的一员
                  1. 传递的参数不能过多,有长度限制
               2. 格式:"/home/1"
               3. 注意点:在声明注册路由对象的时候,需要在path中写好占位符
                  1. path:"/home/:id"
            4. meta
               1. 他不是URL传参的一员
               2. 需要在声明路由对象的时候,在path同级的位置属性meta属性,并向内部写入数据
               3. 通过this.$route.meta即可获取到对应的数据
3. 我们需要提供给VueRouter什么东西?
   1. 配置对象
      1. mode属性
         1. hash
            1. 开启hash模式的路由
            2. **原理:**
               1. **VueRouter会给window对象,绑定hashchange事件用于监视地址栏的变化**
               2. **如果事件回调函数触发了,就读取location.hash的值,将该值赋值给$router身上的响应式属性**
                  1. **最终会导致使用到这个响应式属性的组件都更新(指的就是router-view)**
         2. history
            1. 开启history模式的路由
            2. **原理:**
               1. **VueRouter会给window对象,绑定popstate事件用于监视地址栏的变化**
                  1. **注意:popstate事件,只能在前进后退按钮才能触发事件回调函数**
               2. **如果事件回调函数触发了,就读取location.pathname的值,将该值赋值给$router身上的响应式属性**
                  1. **最终会导致使用到这个响应式属性的组件都更新(指的就是router-view)**
      2. routes属性
         1. 数据类型:routeObj[ ]
         2. routeObj对象结构
            1. path
               1. 代表当前路由的路由地址
            2. component
               1. 如果当前地址栏中的路径,与path匹配,页面就需要显示该组件