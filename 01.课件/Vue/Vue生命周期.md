# Vue生命周期

1. 一共具有多少个生命周期?
   1. 可以说11个,也可以说12个
   2. 如果仅算前端渲染就是11个,如果加上后端渲染专用的生命周期就是12个
   3. 其中常用的8个
2. 阶段划分
   1. 初始化阶段
      1. beforeCreate
         1. 在Root组件的该生命周期中,我们会在Vue的原型对象上,注册事件总线
         2. **beforeCreate之前,Vue在初始化事件和生命周期**
      2. created
         1. 发送请求
            1. 此处由于js是单线程解析的原因,执行时机会早于mounted,所以此处发送请求,出去的时间更早,相对的回来的时间也更早
         2. 不建议在该阶段,做一些比较复杂的逻辑运算,因为如果阻塞代码时间过长,会导致后续挂载操作也会延迟,最终用户看到该组件的时间将会延迟,页面白屏效果明显
         3. **beforeCreate之后created之前,Vue在初始化注入和初始化响应式**
            1. **注入:在组件实力身上,创建一些与data,props,methods,computed等同名的属性,方便用户快速访问这些内容**
            2. **响应式:将data中的属性进行数据劫持,变成响应式属性**
      3. beforeMount
         1. **created之后beforeMount之前,Vue会获取到模版内容,对其进行编译,最终一定会得到当前组件的render函数**
         2. **注意点:**
            1. **优先级:render配置>template配置>el配置**
            2. **beforeMount之前,Vue只是编译得到了render函数,并不会去调用它来产生虚拟DOM**
      4. mounted
         1. 发送请求
            1. 此处发送请求,组件已经挂载结束了,此处执行比较复杂的代码,对页面的影响较小
         2. 操作真实DOM
            1. new Swiper
            2. 滑动库操作(例如:betterScroll)
         3. 开启定时器
         4. 绑定自定义事件
         5. **beforeMount之后mounted之前,Vue会调用render函数创建虚拟DOM,再根据虚拟DOM创建真实DOM,并且替换掉页面上对应el区域**
   2. 更新阶段
      1. beforeUpdate
         1. 此处获取到的数据是最新的,但是组件的DOM结构并不是最新的
      2. updated
         1. 此处获取到的数据是最新的,而且组件的DOM结构也是最新的
         2. 个人认为像是一个监视范围比较大的watch
         3. 二次操作真实DOM
   3. 卸载阶段
      1. beforeDestory
         1. 取消还没触发的定时器
         2. 解绑事件
            1. **当前组件使用@符或者$on绑定的自定义事件,是否需要手动解绑?**
               1. **不需要手动解绑,因为Vue知道当前组件有哪些自定义事件,他会自动解绑**
            2. **原生标签使用@符绑定的原生事件,是否需要手动解绑?**
               1. **不需要手动解绑,因为当DOM节点卸载之后,垃圾回收机制会自动回收这部分的内存**
               2. **扩展:IE浏览器即便DOM节点销毁了,他身上的事件回调函数依旧会遗留**
            3. **原生标签使用addEventListener或者onclick类似于法绑定的原生事件,是否需要手动解绑?**
               1. **如果是绑定在window或者document对象身上的事件,一定要手动解绑**
                  1. **因为即便组件卸载了,也不会导致以上两个对象销毁**
            4. **使用$on语法绑定的全局事件总线,是否需要手动解绑?**
               1. **需要手动解绑,因为无论任何一个组件卸载,都不会导致事件总线对象卸载**
                  1. **那么事件总线对象身上的自定义事件就会出现遗留问题**
      2. destoryed
   4. keep-alive专用
      1. 由于被keep-alive组件嵌套的组件,将会无法卸载,从而无法二次初始化,将会失去初始化阶段和卸载阶段的生命周期
      2.  activated(激活)
         1. 当组件显示的时候会执行
      3. deactivated(失活)
         1. 当组件隐藏的时候会执行
   5. 用于捕获后代组件出现的错误
      1. errorCaptured
   6. 后端渲染专用
      1. ServerPrefetch

