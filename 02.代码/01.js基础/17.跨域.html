<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
      /*
        跨域
            1.跨域是什么?
                跨域是一种操作
                跨域就是违反了浏览器的同源策略

                问题:什么是同源?
                官方的定义:同源就是两个URL的协议名,域名,端口号的三者都相同,就说明这两个URL是同源的
      
                如果出现跨域操作,很有可能出现跨域问题

            2.为什么要有跨域报错?
                跨域之所以要出现报错,目的是为了保证用户的数据安全

                如果跨域了不报错,会导致的结果:
                    假设真网站为A网站,假网站为B网站

                    前提:我们曾经访问过A网站,那么当前电脑就会留下A网站的Cookie数据

                    流程:
                        1.如果我们访问B网站,那么浏览器就会请求B服务器的html文件,并自动展示
                        2.B网站在浏览器后台,使用ajax向A网站发送请求,
                            此时浏览器就会自动将A网站相关的Cookie携带并发送出去
                        3.A网站接收到了流程2中的请求,根据传递过来的Cookie,得知了用户的身份
                            并根据当前用户身份,返回一些用户相关数据
                        4.B网站通过流程3中返回的响应数据,获取到了用户的个人信息
                            他就会通过ajax,再将得到的这些个人信息数据,发送给当前B服务器

                    总结:在此过程中,用户的数据泄露,被B网站获取到,
                        同时由于网络环境不安全,大家失去了对网络安全性的信心
            
            3.注意点:
                1.跨域不一定会报错
                    跨域是一种操作,跨域报错是结果,并没有百分百的联系

                2.什么情况下,跨域会报错?
                    只有在浏览器中,使用ajax发送跨域请求,才会出现跨域报错

                    服务器之间不存在跨域报错
                    浏览器中,img/video/audio/script/link等标签,请求跨域资源也不会报跨域错误

                    问题:哪些请求算是ajax请求?
                    回答:只有通过javascript发送的请求,才有可能是ajax请求

            4.如何解决跨域问题?
                由于现在绝大多数的项目,都是前后端分离项目,所以我们需要学会如何解决跨域问题

                解决跨域问题的方案:3种
                    1.JSONP
                        原理:其实就是使用了script标签请求资源,不会报跨域错误的漏洞实现的

                        流程:
                            1.前端在网页中,准备好存储数据的变量data和接收数据的函数getData
                            2.当网页需要发送请求的时候,可以在网页中创建一个script标签
                                并给该script标签,添加一个src属性
                                    src属性值是后端的接口地址,在接口中可以将函数名称传递给后端
                            3.后端接收到当前函数名称之后,根据需要返回的数据以及函数名称
                                拼接处一个字符串,并将其返回给前端
                            4.前端浏览器接收到当前后端返回的字符串,由于该请求是script发送的
                                所以返回的字符串会作为js代码,自动执行
                                最终前端的getData函数会接受到后端返回的数据

                        优点:
                            1.项目无论是否处于上线阶段,都可以使用

                        缺点:
                            1.前端/后端都麻烦
                                前端需要准备变量还有函数
                                后端需要专门写接口,用于返回对应的文本字符串
                    2.CORS
                        原理:浏览器出跨域报错的目的就是为了保证数据的安全性
                            只要服务器告知浏览器,愿意被当前网页请求,那么浏览器就不会多管闲事了

                        流程:
                            1.服务器在返回响应的时候,在响应头中添加属性,告知浏览器允许跨域请求

                        优点:
                            1.前端正常发请求,不需要做任何特殊的事情
                            2.项目无论是否处于上线阶段,都可以使用

                        缺点:
                            1.前端什么都不用做,但是后端需要做

                    3.proxy
                        原理:让网页不会直接请求目标服务器,避免跨域操作的出现
                            让自家的开发服务器请求目标服务器,服务器之间没有跨域问题

                        流程:
                            1.我们会通过配置proxy规则,提前告知devServer,哪些开头的请求需要转发
                            2.网页在向devServer发送请求的时候,会带上固定的基础路径(例如:/api)
                                目的:为了告知devServer,该请求是需要转发的,让devServer别会错意
                            3.devServer会将当前请求,转发到规则中的target地址上去
                                在转发的过程中,devServer会通过路径重写将/api前缀去除
                                如果不去除,很可能会导致请求失败404
                            4.目标服务器会返回对应接口的数据,给到devServer
                            5.devServer将接收到的数据通过流程1的请求,返回响应,将数据给到浏览器

                        优点:
                            1.不求人,前端自己做好配置即可
                                即便后端死了,这方案都能用

                        缺点:
                            1.该方案,只能在开发的时候使用,项目上线之后就失效了
                                因为项目上线之后,代码都会放在公司的服务器上,不会存在于开发服务器上
                                其实devServer就是公司服务器的一个临时替代品
                
      */
    </script>
  </body>
</html>
